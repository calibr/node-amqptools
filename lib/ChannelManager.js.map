{"version":3,"file":"ChannelManager.js","sourceRoot":"","sources":["../src/ChannelManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { Channel, Connection, connect as amqpConnect } from \"amqplib/callback_api\"\nimport Promise = require('bluebird');\nimport { EventEmitter } from \"events\";\nimport util = require('util');\nimport _ = require('lodash');\n\nconst MAX_LISTENERS = 10000;\n\nvar debug = util.debuglog(\"amqptools\");\n\nexport class ChannelManager extends EventEmitter {\n  connectionURI: string;\n  channel: Channel;\n  channelPromise: Promise<Channel>;\n  connection: Connection;\n  maxReconnectionAttempts = 100;\n  randomReconnectionInterval = true;\n\n  eventListeners: Event\n\n  private connectCallbacks: ((err: Error, channel: Channel) => void)[] = [];\n  private connectInProgress: boolean;\n\n  constructor() {\n    super();\n    this.setMaxListeners(MAX_LISTENERS);\n  }\n\n  onConnectionClose = (error) => {\n    debug(\"amqp connection has been closed\");\n    this.channel = null;\n    this.connection = null;\n    this.channelPromise = null;\n    var reconnections = 0;\n    var tryReconnect = () => {\n      debug(\"Reconnection attempt...\");\n      this.connect((err) => {\n        reconnections++;\n        if (!err) {\n          this.emit(\"reconnect\");\n          return debug(\"Connection has been restored\");\n        }\n        if (reconnections >= this.maxReconnectionAttempts) {\n          throw new Error(\"Fail to establish a connection with rabbitmq\");\n        }\n        var timeout = this.randomReconnectionInterval ? _.random(1, 10) : 1;\n        debug(\"Next reconnect in %d seconds\", timeout);\n        setTimeout(tryReconnect, timeout * 1000);\n      });\n    };\n    tryReconnect();\n  }\n\n  connect(cb) {\n    if (this.channel) {\n      return cb(null, this.channel);\n    }\n\n    this.connectCallbacks.push(cb);\n    if (this.connectInProgress) return;\n    this.connectInProgress = true;\n\n    amqpConnect(this.connectionURI, (err, connection) => {\n      if (err) {\n        return this.connectRespond(err, null);\n      }\n      this.connection = connection;\n      this.connection.on(\"close\", this.onConnectionClose);\n      this.connection.createChannel((err, channel) => {\n        if (err) {\n          return this.connectRespond(err, null);\n        }\n        this.channel = channel;\n\n        this.channel.on('error', () => { this.reconnect() });\n\n        this.connectRespond(null, this.channel)\n      });\n    });\n  }\n\n  connectRespond(err, channel) {\n    this.connectInProgress = false;\n    if (err) {\n      debug(\"Fail to connect...\", err);\n    }\n    else {\n      debug(\"Connected\");\n    }\n    this.connectCallbacks.forEach((extraCb) => {\n      if (!extraCb) return;\n      extraCb(err, channel);\n    });\n    this.connectCallbacks = [];\n  }\n\n  getChannel(): Promise<Channel> {\n    return new Promise<Channel>((resolve, reject) => {\n      if (this.channel) {\n        return resolve(this.channel);\n      }\n      this.connect((err, channel) => {\n        if (err) return reject(err);\n        resolve(channel);\n      })\n    });\n  }\n\n  setConnectionURI(uri) {\n    this.connectionURI = uri;\n  }\n\n  disconnect(cb) {\n    if (!this.connection) {\n      return cb();\n    }\n    this.connection.removeListener(\"close\", this.onConnectionClose);\n    this.connection.close(() => {\n      this.connection = null;\n      this.channel = null;\n      this.channelPromise = null;\n      cb();\n    });\n  }\n\n  reconnect(cb?) {\n    this.disconnect(() => {\n      this.connect(cb);\n    });\n  }\n}\n\nexport var channelManager = new ChannelManager();"]}