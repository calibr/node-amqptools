{"version":3,"file":"EventEmitter.js","sourceRoot":"","sources":["../src/EventEmitter.ts"],"names":[],"mappings":"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","sourcesContent":["import * as events from \"events\";\nimport * as util from \"util\";\nimport * as async from \"async\";\nimport { channelManager } from './ChannelManager';\nimport { Event } from \"./Event\";\nimport { EventListener } from \"./EventListener\";\nimport { promiseNodeify } from './promise-nodeify';\n\nvar EventEmitter = events.EventEmitter,\n  addListenerMethods = [\"addListener\", \"on\", \"once\"],\n  copyMethods = [\"removeListener\", \"removeAllListeners\", \"setMaxListeners\", \"listeners\"];\n\nfunction parseEvent(event) {\n  var tmp = event.split(\":\");\n  return {\n    exchange: tmp[0],\n    topic: tmp[1]\n  };\n}\n\nexport interface EventsListeners {\n  [index: string]: EventListener\n}\n\nexport interface EventOptions {\n  event: string\n  persistent?: boolean\n  autoAck?: boolean\n  prefetchCount?: number\n}\n\nexport class AMQPEventEmitter {\n  runtime: string;\n  ee: events.EventEmitter;\n  private eventsListeners: EventsListeners;\n\n  constructor(runtime) {\n    this.runtime = runtime || \"\";\n    this.ee = new EventEmitter();\n    this.eventsListeners = {};\n\n    addListenerMethods.forEach((method) => {\n      this[method] = (options, cb, eventSetCb) => {\n        if (typeof options === \"string\") {\n          options = {\n            event: options\n          };\n        }\n        let event = options.event;\n        if ([\"newListener\", \"removeListener\"].indexOf(event) !== -1) {\n          return this.ee[method].call(this.ee, event, cb);\n        }\n        // add listener to the event emitter before attaching to queue in order to be ready if messages are received\n        // before preListen callback is called\n        this.ee[method].call(this.ee, event, cb);\n        return this.preListen(options, (err) => {\n          if (err) {\n            this.ee.removeListener(event, cb);\n          }\n          if (eventSetCb) {\n            eventSetCb(err);\n          }\n        });\n      };\n    });\n\n    copyMethods.forEach((method) => {\n      this[method] = (...args: any[]) => {\n        this.ee[method].apply(this.ee, args);\n      };\n    });\n  }\n\n  private preListen(options, cb) {\n    var event = options.event;\n    var eParsed = parseEvent(event);\n\n    if (this.eventsListeners[event]) {\n      return cb(null);\n    }\n\n    Object.assign(options, {\n      exchange: eParsed.exchange,\n      topic: eParsed.topic,\n      runtime: this.runtime\n    })\n    var eventListener = new EventListener(options);\n\n    this.eventsListeners[event] = eventListener;\n    let promise = eventListener.listen((message, extra) => {\n      var content = message.content;\n      if (Array.isArray(content) && content.length === 1 && content[0].context && content[0].message) {\n        // old formatted message\n        content = content[0];\n      }\n      this.ee.emit.call(this.ee, event, content, extra);\n    });\n\n    return promiseNodeify(promise, cb);\n  }\n\n  emit(event, data) {\n    var eParsed = parseEvent(event);\n\n    var amqpEvent = new Event({\n      exchange: eParsed.exchange,\n      topic: eParsed.topic\n    });\n\n    amqpEvent.send(data);\n  };\n\n  addListener(event: string | EventOptions, listener: Function, cb?: Function) { };\n  on(event: string | EventOptions, listener: Function, cb?: Function) { };\n  once(event: string | EventOptions, listener: Function, cb?: Function) { };\n  removeListener(event: string, listener: Function) { };\n  removeAllListeners(event?: string) { };\n  setMaxListeners(n: number) { };\n  listeners(event: string) { };\n}"]}